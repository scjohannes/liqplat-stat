---
Title: Simulation where OR = 0.8 - 6M Only
---


## Setup
```{r}
# Load Libraries
library(Hmisc)
library(rmsb)
library(ggplot2)
library(arrow)
library(tidyverse)
library(data.table)
library(furrr)
library(glue)
```

## Load data

```{r}
set.seed(1234)

# Load full dataset
df_full <- read_parquet("./1-qol/sim-data/sim_data_nonpo.parquet") |> 
    filter(tx == 0) |> 
    group_by(id) |> 
    mutate(tx = sample(c(0, 1), size = 1)) |> 
    ungroup()
```


## Simulation function

```{r}
run_simulation_iteration <- function(iter_num, base_path, full_data) {
    # This function runs one full simulation iteration.
    
    # --- 1. Setup for the current iteration ---
    set.seed(123 + iter_num)
    iter_path <- file.path(base_path, glue("run_{iter_num}"))
    if (!dir.exists(iter_path)) {
        dir.create(iter_path, recursive = TRUE)
    }

    # --- 2. Sample Patients ---
    ss_tx <- 180
    ss_control <- 90

    tx_ids <- sample(full_data |> filter(tx == 1) |> pull(id) |> unique(), ss_tx, replace = FALSE)
    control_ids <- sample(full_data |> filter(tx == 0) |> pull(id) |> unique(), ss_control, replace = FALSE)

    df_iter <- full_data |>
        filter(id %in% c(tx_ids, control_ids))

    rm(full_data)

    # --- 3. Pre-process Data & Save Empirical SOPs ---
    ids_death <- df_iter$id[df_iter$y == '8']
    df_filtered <- df_iter |>
        filter(!(id %in% ids_death))

    # Save empirical SOP image for this iteration's data
    p_empirical <- df_filtered |>
        ggplot(aes(x = time, fill = factor(y))) +
        geom_bar(position = "fill") +
        scale_fill_brewer(palette = "Dark2") +
        facet_wrap(~tx) +
        labs(
            title = glue("Empirical State Occupancy Probabilities for Run {iter_num}"),
            subtitle = "After removing patients who died during follow-up",
            x = "Time", y = "Proportion", fill = "State"
        )
    
    pdf(file = file.path(iter_path, "empirical_sops.pdf"), width = 8, height = 6)
    print(p_empirical)
    dev.off()

    # we keep baseline measurement
    baseline <- df_filtered |>
        filter(time == 1) |>
        mutate(y = yprev, time = 0) |>
        select(id, ybaseline = y)

    # --- 4. Create analysis for timepoint 6m only
    data_for_model <- df_filtered |>
        slice_sample(prop = 0.15) |> 
        filter(time > 14) |> 
        group_by(id) |> 
        arrange(desc(time)) |> 
        slice_head(n = 1) |> 
        ungroup() |> 
        left_join(baseline, by = "id") |> 
        # refactor ecog and diagnosis in case a level was dropped during sampling
        mutate(
                ecog_fstcnt = factor(ecog_fstcnt),
                diagnosis = factor(diagnosis)
            )

    # --- 5. Save the data used for model fitting ---
    saveRDS(data_for_model, file.path(iter_path, "data_for_model.rds"))

     # --- 6. Fit the Model and Save ---
    if (nrow(data_for_model) > 0) {
        model <- tryCatch({
            # The code to try
            blrm(
                formula = y ~ tx + ybaseline + ecog_fstcnt + diagnosis,
                data = data_for_model,
                refresh = 0,
                iter = 2000,
                chains = 4,
                method = "sampling",
                seed = 1234 + iter_num,
                cores = 1,
                loo = FALSE
            )
        }, error = function(e) {
            message(glue("ERROR in iteration {iter_num}: {e$message}"))
            
            saveRDS(data_for_model, file.path(iter_path, "problematic_data.rds"))
            
            return(NULL)
        })

        # --- 7. Save the results ONLY if the model ran successfully ---
        if (!is.null(model)) {
            # Save the full model object
            # saveRDS(model, file.path(iter_path, "model_object.rds"))
            
            # Save just the MCMC draws to a separate file
            saveRDS(as.data.table(model$draws), file.path(iter_path, "model_draws.rds"))

            rhat_values <- stanDx(model) |> 
                data.frame() |> 
                rownames_to_column()  |> 
                select(-n_eff) |> 
                pivot_wider(names_from = rowname, values_from = Rhat)

            saveRDS(rhat_values, file.path(iter_path, "rhat_values.rds"))

            ess_ratios <- stanDx(model) |> 
                data.frame() |> 
                rownames_to_column()  |> 
                select(-Rhat) |> 
                pivot_wider(names_from = rowname, values_from = n_eff) |> 
                mutate_all(~ . / (model$iter * model$chains))

             saveRDS(ess_ratios, file.path(iter_path, "ess_ratios.rds"))
        }
    }
    
    gc()
    return(glue("Iteration {iter_num} completed."))
}
```

## Run Parallelized Simulation
```{r}
N_SIMULATIONS <- 1000 
OUTPUT_PATH <- "./1-qol/output/sim-principal-stratum-6m-only-H0/"
N_CORES <- 10

message("Checking for previously completed simulation runs...")

completed_files <- fs::dir_ls(path = OUTPUT_PATH, glob = "*/model_draws.rds", recurse = TRUE)

completed_iters <- integer(0) 
if (length(completed_files) > 0) {
    completed_iters <- stringr::str_extract(completed_files, "(?<=run_)\\d+") |>
        as.integer() |>
        na.omit() |>
        unique()
}

# Determine which iterations still need to be run
all_possible_iters <- 1:N_SIMULATIONS
iters_to_run <- setdiff(all_possible_iters, completed_iters)

n_to_run <- length(iters_to_run)
n_completed <- length(completed_iters)

message(glue("{n_completed} of {N_SIMULATIONS} iterations are already complete."))

if (n_to_run > 0) {
    message(glue("Starting {n_to_run} new simulations on {N_CORES} cores..."))
    
    future::plan(future.callr::callr, workers = N_CORES)
    
    # --- Run Simulations in Parallel ---
    furrr::future_walk(
        .x = iters_to_run,
        .f = ~run_simulation_iteration(
            iter_num = .x,
            base_path = OUTPUT_PATH,
            full_data = df_full
        ),
        .options = furrr_options(seed = TRUE),
        .progress = TRUE
    )
    
    message(glue("Finished {n_to_run} simulations."))
} else {
    message("All simulations were already complete. No new runs started.")
}

message("Simulation process finished.")
```