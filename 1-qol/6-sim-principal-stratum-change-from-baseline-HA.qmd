---
Title: Change from Baseline (underlying OR = 0.8)
---


## Setup
```{r}
# Load Libraries
library(Hmisc)
library(ggplot2)
library(arrow)
library(tidyverse)
library(data.table)
library(furrr)
library(glue)
library(brms)
library(marginaleffects)
```

## Load data

```{r}
set.seed(1234)
# Load full dataset
df_full <- read_parquet("./1-qol/sim-data/sim_data_nonpo.parquet")

model <- readRDS("./1-qol/models/model-change-from-baseline.rds")

# These are the model specs
# model <- brm(
#   y_delta ~ 1 + tx + ecog_fstcnt + diagnosis + ybaseline,
#   data = data_for_model,
#   cores = 4,
#   seed = 1,
#   init_r = 0.2,
#   iter = 2000,
#   file_refit = "on_change",
#   file = "./1-qol/models/model-change-from-baseline.rds"
# )
```

## Calculate "true" Change from Baseline

```{r}

ids_death <- df_full$id[df_full$y == '8']

change_from_baseline <- df_full |>
        filter(!(id %in% ids_death)) |> 
        group_by(id) |> 
        mutate(
            ybaseline = as.numeric(as.character(yprev[time == 1])),
            y = as.numeric(as.character(y)),
            ydelta = y - ybaseline) |> 
        ungroup() |> 
        filter(time == 26) |> 
        group_by(tx) |> 
        summarise(mean_ydelta = mean(ydelta))
```

## Simulation function

```{r}
run_simulation_iteration <- function(iter_num, base_path, full_data, model) {
    # This function runs one full simulation iteration.
    
     # --- 1. Setup for the current iteration ---
    set.seed(123 + iter_num)
    iter_path <- file.path(base_path, glue("run_{iter_num}"))
    if (!dir.exists(iter_path)) {
        dir.create(iter_path, recursive = TRUE)
    }

    # --- 2. Sample Patients ---
    ss_tx <- 180
    ss_control <- 90

    tx_ids <- sample(full_data |> filter(tx == 1) |> pull(id) |> unique(), ss_tx, replace = FALSE)
    control_ids <- sample(full_data |> filter(tx == 0) |> pull(id) |> unique(), ss_control, replace = FALSE)

    df_iter <- full_data |>
        filter(id %in% c(tx_ids, control_ids))

    rm(full_data)

    # --- 3. Pre-process Data & Save Empirical SOPs ---
    ids_death <- df_iter$id[df_iter$y == '8']
    df_filtered <- df_iter |>
        filter(!(id %in% ids_death))

    # Save empirical SOP image for this iteration's data
    p_empirical <- df_filtered |>
        ggplot(aes(x = time, fill = factor(y))) +
        geom_bar(position = "fill") +
        scale_fill_brewer(palette = "Dark2") +
        facet_wrap(~tx) +
        labs(
            title = glue("Empirical State Occupancy Probabilities for Run {iter_num}"),
            subtitle = "After removing patients who died during follow-up",
            x = "Time", y = "Proportion", fill = "State"
        )
    
    pdf(file = file.path(iter_path, "empirical_sops.pdf"), width = 8, height = 6)
    print(p_empirical)
    dev.off()

    # we keep baseline measurement
    baseline <- df_filtered |>
        filter(time == 1) |>
        mutate(y = yprev, time = 0) |>
        select(id, ybaseline = y)

    # --- 4. Create analysis for timepoint 6m only
    data_for_model <- df_filtered |>
        slice_sample(prop = 0.15) |> 
        filter(time > 14) |> 
        group_by(id) |> 
        arrange(desc(time)) |> 
        slice_head(n = 1) |> 
        ungroup() |> 
        left_join(baseline, by = "id") |> 
        # refactor ecog and diagnosis in case a level was dropped during sampling
        mutate(
            ecog_fstcnt = factor(ecog_fstcnt),
            diagnosis = factor(diagnosis)) |> 
        mutate(
            ybaseline = as.numeric(as.character(ybaseline)),
            y         = as.numeric(as.character(y)),
            y_delta   = y - ybaseline) # negative change is good

    # --- 5. Save the data used for model fitting ---
    saveRDS(data_for_model, file.path(iter_path, "data_for_model.rds"))


    # --- 6. Fit the Model and Save ---
    if (nrow(data_for_model) > 0) {
        model <- tryCatch({
            update(
                model, 
                newdata = data_for_model
                )
        }, error = function(e) {
            message(glue("ERROR in iteration {iter_num}: {e$message}"))
            
            saveRDS(data_for_model, file.path(iter_path, "problematic_data.rds"))
            
            return(NULL)
        })

        # --- 7. Save the results ONLY if the model ran successfully ---
        if (!is.null(model)) {
            # Save the full model object
            # saveRDS(model, file.path(iter_path, "model_object.rds"))
            
            # Save just the MCMC draws to a separate file
            saveRDS(brms::as_draws_df(model), file.path(iter_path, "model_draws.rds"))

            rhat_values <- brms::rhat(model) |> 
                data.frame() |> 
                rownames_to_column() |> 
                pivot_wider(names_from = rowname, values_from = brms..rhat.model.)

            saveRDS(rhat_values, file.path(iter_path, "rhat_values.rds"))

            ess_ratios <- brms::neff_ratio(model) |> 
                data.frame() |> 
                rownames_to_column() |> 
                pivot_wider(names_from = rowname, values_from = brms..neff_ratio.model.)

            saveRDS(ess_ratios, file.path(iter_path, "ess_ratios.rds"))
        }
    }
    
    # Return a status message for progress tracking
    return(glue("Iteration {iter_num} completed."))
}
```

## Run Parallelized Simulation
```{r}
# --- User-defined Parameters ---
N_SIMULATIONS <- 1000
OUTPUT_PATH <- "./1-qol/output/sim-principal-stratum-change-from-baseline-HA/" # Base path for all output
N_CORES <- 6

message("Checking for previously completed simulation runs...")

completed_files <- fs::dir_ls(path = OUTPUT_PATH, glob = "*/model_draws.rds", recurse = TRUE)

completed_iters <- integer(0) 
if (length(completed_files) > 0) {
    completed_iters <- stringr::str_extract(completed_files, "(?<=run_)\\d+") |>
        as.integer() |>
        na.omit() |>
        unique()
}

# Determine which iterations still need to be run
all_possible_iters <- 1:N_SIMULATIONS
iters_to_run <- setdiff(all_possible_iters, completed_iters)

n_to_run <- length(iters_to_run)
n_completed <- length(completed_iters)

message(glue("{n_completed} of {N_SIMULATIONS} iterations are already complete."))

if (n_to_run > 0) {
    message(glue("Starting {n_to_run} new simulations on {N_CORES} cores..."))
    
    future::plan(future.callr::callr, workers = N_CORES)
    
    # --- Run Simulations in Parallel ---
    furrr::future_walk(
        .x = iters_to_run,
        .f = ~run_simulation_iteration(
            iter_num = .x,
            base_path = OUTPUT_PATH,
            full_data = df_full,
            model = model
        ),
        .options = furrr_options(seed = TRUE),
        .progress = TRUE
    )
    
    message(glue("Finished {n_to_run} simulations."))
} else {
    message("All simulations were already complete. No new runs started.")
}

message("Simulation process finished.")
```